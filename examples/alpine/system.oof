# This file is part of the OOF project, released under the Creative Commons CC0
# https://creativecommons.org/publicdomain/zero/1.0/

# An example system: Alpine, perhaps within QEMU
# It also serves as an example of OOF files
#
# Unless escaped with a backslash (\#), all characters following a # to the end
# of the line are considered comments, and are ignored

# The first non-comment stanza *must* be an OOF incantation, telling the
# interpreter what type of OOF file it is reading (and thus, dictating which
# commands are available). Since we're building a system, we'll tell OOF to use
# the system grammar, and that we're writing against v2021.06.10 of the spec.
# In general, most things in OOF follow [Chronver
# 2019.05.19](https://chronver.org/spec/2019.05.19)
OOF --system="2021.06.10"

# Each of these stanzas is metadata for the OOF database, however, at least
# LICENSE is required somewhere within the file, and follows (most of) the
# format specified at https://spdx.dev/ids/, for example, perhaps
# "GPL-3.0-or-later OR MIT". For proprietary or other non-SPDX-identifiable OOF
# files, `LICENSE "restricted"` or `LICENSE "proprietary"` (case-inspecific)
# can be used, and will trigger a confirmation-required warning to the end user
# at runtime that they are using an OOF file they require permission from the
# author to use. To bypass this confirmation (for example, on corporate
# infrastructure), use OOF_COPYRIGHTED_CONTENT_ALLOWED=1 in the environment. It
# is recommended that MAINTAINER is set if LICENSE is non-SPDX-identifiable.
MAINTAINER "klardotsh <josh@klar.sh>"
HOMEPAGE "https://code.klar.sh"
LICENSE "CC0-1.0"

# Configurations can extend any number of other configurations if known by OOF.
# Namespaces are added using the `USING` stanza, and can refer to any file
# path, or HTTP(S) or Git URL by default. Fetchers for other protocols can be
# added by the `oof` CLI, perhaps: `oof --fetcher:svn=~/bin/oof-svn-fetcher`.
# See `man 5 oof-fetcher` for details.
#
# The `oof` namespace always exists by default, and will be a local copy of the
# canonical configurations repo, which lives at <URL when known>. However, it
# can be overridden at runtime in the standard way. For example, here we lock
# it to a fictional git commit, 1234567.
USING "oof" --git=https://code.klar.sh/oof-config-bases --rev=1234567

# The EXTENDS stanza can be used as many times as desired to merge
# configurations - for example, it is almost always desired to extend a base
# system definition that tells OOF what the system looks like on a fresh
# install, so that it doesn't go about removing core system components when it
# detects them installed! These base configurations also define important but
# mundane things such as telling OOF which underlying package manager to call
# out to. The : syntax refers to a subdirectory of wherever @oof is stored,
# which in this case means we expect the git repository requested above to
# contain a file at the path "systems/linux/alpine/3.13.5{.oof}" (extension
# optional, though will be prioritized over files without such extension).
EXTENDS --alias="alpine" @oof:systems/linux/alpine/3.13.5

# LET allows assigning values a name for future reference with @, much like the
# `let` keyword in many programming languages. List values are denoted with
# brackets `[]`, with elements whitespace and/or semicolon separated. Newlines
# are just plain old whitespace, and thus are ignored, allowing lists to span
# any number of lines.
LET extra-user-groups [
	"wheel"
	"storage"
	"audio"
	"video"
]

# For giggles, this is an example of a hash map in case you need it. Unused
# assignments that aren't exposed with --expose will trigger linter warnings
# (see `man 1 oof-lint`)
#
# Entries in a hash map are separated by newlines and/or by semicolons
LET unused-data {
	numerical = 0
	other-numerical = 0.0
	some-string = "a string goes here"
	must-be-used-in-a-package[@oof/pkg-req("applications/text/ripgrep")] = "something"
	# ^ Brackets after a key name are tags, separated by whitespace and/or
	# semicolons, which serve as something resembling an intent system (as
	# opposed to a type system as in, say, ML languages). These tags are
	# provider-specific, but @oof/pkg-req, a built-in, hints to the solver that
	# if this entry is only ever referenced outside of an intent that would
	# install a package, the system would end up in an illegal state of some
	# form - this allows powerful reference passing, for example, by allowing
	# setting a user's shell by constant, with the OOF solver ensuring that the
	# shell is actually installed on the resultant system. Tags can take
	# arguments, which follow the same syntax rules as any other command, other
	# than that they must be contained within parentheses (the opening of which
	# must not be separated from the tag itself - this should look familiar to
	# those with C-style language syntax experience). In this example,
	# @oof/pkg-req requires an argument that is the name of the package-intent
	# that must be fulfilled somewhere in the system configuration. This is
	# almost never the actual package name on any distribution.
}

# Any command can span as many lines as necessary as long as all continuations
# are indented (indentation within a block must be consistent. File-wide
# consistency is recommended, but not enforced by the interpreter; to enforce
# this, use `oof fmt`, documented in `man 1 oof-fmt`).
USER
# ^ technically this is @oof/USER, but commands from the @oof namespace (whatever it
# happens to be when evaluating the configuration at hand) are hoisted to the global
# scope for ergonomics' sake
	"j"
	--full-name="Josh Klar"
	--uid=1000
	--main-group="users"
	# @ refers to a value which has previously been assigned with LET.
	# Assignments exposed (with LET --expose) in files which have been imported
	# with EXTENDS can be referenced using their path, a colon, and the variable
	# name. For example:
	# --extra-groups=@oof:systems/linux/alpine/3.13.5:some-example-variable
	#
	# Since that wordiness would get old pretty quickly, EXTENDS can take a
	# --alias argument, and the variable can then be referenced by either the
	# fully-qualified path, or the alias.
	#
	# It's important to note that assigning two values the same name in the
	# same scope is an interpret-time error, and that LETs and USINGs share a
	# namespace.
	--extra-groups=@extra-user-groups
	# since @alpine/shells is a hashmap, we look up entries in it with /, just
	# like we do in all other contexts. also, remember intent tags?
	# @alpine/shells/zsh uses the aforementioned @oof/pkg-req tag, meaning we'll
	# need to somehow ensure something providing that shell gets installed elsewhere
	# in our configuration. we'll handle that later...
	--shell=@alpine/shells/zsh

SHELL "zsh" # oh hey! this fulfills the @oof/pkg-req intent from @alpine/shells/zsh!
	--completion=m # booleans are "yes|y", "no|n", and "maybe|m"... which makes them
	               # not actually booleans, I'm well aware. binaries are overrated.

# only one shell can be --is-bin-sh! command arguments accept tags similarly to
# how hashmaps do, and they can have implicit tags. `SHELL` defines
# `--is-bin-sh` with an implicit tag of `[@oof/priority 9]`, which by
# convention is reserved for end-user code (system definitions and other
# non-end-user definitions of this tag will always try to stay under 8). this
# value can technically be any 8-bit unsigned integer, so `@oof/priority 255`
# is valid if so needed, but beware the `z-index: 999999999999999 !important`
# conundrum
SHELL "dash" --is-bin-sh=y

WINDOWMANAGER "sway"
	--swaylock=y
	--swayidle=y
	--swaybar=n

# INTENTPKGS is a way to install auxilliary packages not brought in by some other command,
# but without having to specify the distribution-specific package name. For example, asking
# for "cryptography/openssl" would ensure OpenSSL ends up on the system assuming the
# distribution abstraction mapas the package, regardless of whether said package is called
# "openssl", "libopenssl", or "OpenSSL"
#
# --best-effort here will warn if an intent can't be fulfilled rather than
# erroring. INTENTPKGS can be called as many times as you'd like, so it's
# likely useful to have a call without --best-effort to handle anything you
# MUST have, and then another with the flag to try to get as much of the rest
# as you can
INTENTPKGS --best-effort [
	"application/text/ripgrep"
]

# PKGS is the lowest level package installer, and is almost certainly not portable across
# distributions, so is probably only useful at the highest level (where you've inherited
# your shared configs, and now need a few distro- and machine-specific packages to fill
# some gaps). It simply calls out to the underlying package manager, allowing you to install
# anything your distribution packages.
#
# --best-effort is supported here, too
PKGS [
	"alpine-doc"
]
